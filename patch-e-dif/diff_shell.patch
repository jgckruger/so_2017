--- S04_AP_04.1_23.03.2017__shellsimples.c	2017-03-23 00:01:39.711058000 -0300
+++ shellsimples.c	2017-04-01 18:48:56.475166000 -0300
@@ -1,42 +1,79 @@
 /***************************************************************
-  DISCIPLINA: 203065 - Sistemas Operacionais 
+DISCIPLINA: 203065 - Sistemas Operacionais
+
+Shell para execuÔøΩÔøΩo de comandos simples;
+- Esse cÔøΩdigo roda em Linux;
+- O que fazer para portar para o Xv6?
+- ver cÔøΩdigo do sh.c
+
+1. Mudado os printf("string") para printf(1, "string") - Sa√≠da padr√£o
+2. Removidas as bibliotecas stdio e stdlib - N√£o existem no xv6
+3. Adicionada a biblioteca do printf no xv6 (user.h)
+4. Removido o par√¢metro do exit - N√£o existe no xv6
+5. Adicionado o tamanho da string com o comando no gets - Obrigat√≥rio no xv6
+6. Removido o parametro do wait - Isso talvez n√£o esteja certo, conferir com o dierone
+7. Adicionada a biblioteca types.h antes da user, ela cont√©m a declara√ß√£o dos tipos
+- Solu√ß√£o poss√≠vel para o futuro: adicionar a defini√ß√£o na pr√≥pria user.h
+- Resolveria a depend√™ncia? Criaria re-declara√ß√µes? Deveria ser feita em outras libraries?
+8. Mudado de execvp para exec - Isso talvez n√£o esteja certo, conferir com o dierone
+9. Mudar o NULL para 0 no strtok - NULL n√£o √© definido no xv6
+- Solu√ß√£o poss√≠vel para o futuro: adicionar a constante NULL na types.h
+10. Arrumar o strtok - Perguntar ao dierone
+- Implementar strtok ou achar alternativa, aparentemente n√£o existe no xv6
+11. Mudada a saida padr√£o dos erros para a 2 (stderr)
+12. Adicionado o arquivo da strtok na pasta e incluido o arquivo
+13. O gets l√™ o \n final
+- Solu√ß√£o: adicionar no strtok o '\n' como delimitador
+- Solu√ß√£o alternativa: adicionar o 0 na ultima posicao do vetor (depois da verifica√ß√£o pra nao dar underflow)
 
-  Shell para execuÁ„o de comandos simples;
-     - Esse cÛdigo roda em Linux;
-     - O que fazer para portar para o Xv6?
-		- ver cÛdigo do sh.c
 
 ***************************************************************/
 
-#include <stdlib.h>
-#include <string.h>
+#include "types.h" // header com a defini√ß√£o dos tipos usados pela user.h
+
+#include "user.h" // header com os cabe√ßalhos de syscalls e fun√ß√µes.
+// possui as syscalls aqui usadas: fork, exit, wait, exec
+// possui as fun√ß√µes aqui usadas: strcmp, printf, gets, strlen
+
+#include "strtok.c" // arquivo com o c√≥digo fonte da fun√ß√£o strtok (n√£o nativa do xv6)
+
 
 int main( void )
 {
- char lc[ 81 ];
- char *argv[ 20 ];
- int pid, i, status;
-
- while( 1 ) {
- 	printf( "Prompt > " );
-	gets( lc );
-	if( ! strcmp( lc, "" ) )
- 		continue;
- 	argv[ 0 ] = strtok( lc, " " );
- 	if( ! strcmp( argv[ 0 ], "exit" ) )
- 		exit( 0 );
-	i = 1;
-	while( i < 20 && (argv[ i ] = strtok( NULL, " " )) )
-		 ++i;
-	if( (pid = fork()) == -1 ) {
-		 printf( "Erro no fork\n" );
-		 exit( 1 );
-	}
-	if( pid == 0 )
-	if( execvp( argv[ 0 ], argv ) ) {
-		printf( "Erro no execv\n" );
-		exit( 1 );
- 	}
-	 wait( &status );
- }
+  char lc[ 81 ]; // buffer de entrada do shell
+  char *argv[ 20 ]; // vetor de strings para separar os argumentos e fun√ß√µes
+  int pid, i; // process id e contador
+
+  while( 1 ) { // loop at√© dar sa√≠da
+    printf(1, "Prompt > " ); // escreve na sa√≠da padr√£o (stdout ou 1) que est√° pronto para receber instru√ß√µes
+    gets( lc , 81); // l√™ buffer de entrada
+    if( ! strcmp( lc, "" ) ) // se a entrada n√£o for nula continua a rodar
+    continue;
+    lc[strlen(lc)-1]=0; // retira o \n do fim da string de entrada visto que o gets a l√™
+    // tamanho da string -1 (come√ßa no 0) deve ser nulo pra tirar o \n
+    argv[ 0 ] = strtok( lc, " " ); // carrega o nome da instru√ß√£o para a primeira posi√ß√£o do vetor argv
+    if( ! strcmp( argv[ 0 ], "exit" ) ) // se a instru√ß√£o for sair ent√£o
+    exit(  ); // d√™ a syscall para parar a execu√ß√£o e sair do programa
+    i = 1;
+    while( i < 20 && (argv[ i ] = strtok( 0, " " )) ) // carrega para o vetor argv os par√¢metros da fun√ß√£o lida
+    ++i;
+    if( (pid = fork()) == -1 ) { // se a syscall de fork teve problema
+      printf(2, "Erro no fork\n" ); // escreva na sa√≠da padr√£o de erro(stderr ou 2) que deu erro ao criar o filho
+      exit(  ); // d√™ a syscall para parar a execu√ß√£o e sair do programa
+    }
+    /*
+    A partir do fork existem duas linhas de execu√ß√£o: a do processo filho e a do pai
+    o fork faz com que seja feita uma c√≥pia bin√°ria(byte por byte) do programa que chamou o fork
+    no processo pai a vari√°vel pid recebe a id do processo filho
+    no processo filho a vari√°vel pid recebe 0
+    */
+
+
+    if( pid == 0 ) // se esse √© o processo filho
+      if( exec( argv[ 0 ], argv ) ) { // se a execu√ß√£o do filho teve algum problema e n√£o retornou 0
+        printf(2, "Erro no execv\n" ); // escreva na sa√≠da padr√£o de erro(stderr ou 2) que deu erro ao rodar o programa
+        exit(  ); // d√™ a syscall para parar a execu√ß√£o e sair do programa
+    }
+    wait(); // espera o processo filho terminar sua execu√ß√£o para voltar ao come√ßo do loop
+  }
 }
